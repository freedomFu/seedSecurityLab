# Buffer-Overflow Vulnerability Lab
缓冲区溢出漏洞
> 本实验的学习目标是让学生通过将他们从课堂上学到的有关漏洞的知识付诸实践，获得有关缓冲区溢出漏洞的第一手经验。缓冲区溢出被定义为程序试图在预分配的固定长度缓冲区的边界之外写入数据的条件。恶意用户可以利用此漏洞来更改程序的流控制，甚至执行任意代码。**此漏洞的出现是由于数据存储（例如缓冲区）和控件存储（例如返回地址）的混合：数据部分的溢出会影响程序的控制流，因为溢出会改变返回地址。**

> 向学生提供了一个存在缓冲区溢出问题的程序，他们需要利用此漏洞来获取root特权。此外，学生还将尝试几种已在Linux中实现的保护方案，并评估其有效性。

## 实验预览
该实验室的学习目标是让学生通过将他们从课堂上学到的有关漏洞的知识付诸实践，获得有关缓冲区溢出漏洞的第一手经验。缓冲区溢出被定义为程序试图在预分配的固定长度缓冲区的边界之外写入数据的条件。恶意用户可以使用此漏洞来更改程序的流控制，从而导致执行恶意代码。此漏洞的出现是由于数据存储（例如缓冲区）和控件存储（例如返回地址）的混合：数据部分的溢出会影响程序的控制流，因为溢出会改变返回地址。

在本实验中，将为学生提供一个具有缓冲区溢出漏洞的程序；他们的任务是开发一种利用该漏洞并最终获得root特权的方案。除攻击外，还将指导学生逐步介绍几种已在操作系统中实施的保护方案，以**应对缓冲区溢出攻击**。学生需要评估该计划是否有效，并解释原因。本实验涵盖以下主题：
- Buffer overflow vulnerability and attack 缓冲区溢出漏洞和攻击
- Stack layout in a function invocation 函数调用中的堆栈布局
- Shellcode shellcode是一段用于利用软件漏洞而执行的代码，shellcode为16进制的机器码，因为经常让攻击者获得shell而得名。shellcode常常使用机器语言编写。 可在暂存器eip溢出后，塞入一段可让CPU执行的shellcode机器码，让电脑可以执行攻击者的任意指令。
- Address randomization 地址随机化
- Non-executable stack 不可执行的堆栈
- StackGuard 堆栈保护

## 实验任务
### 关闭对策 Turning Off Countermeasures
Ubuntu和其他Linux发行版已经实现了几种安全机制，以使缓冲区溢出攻击变得困难。

为了简化攻击，我先禁用它们。然后再我们将一一启用它们，并查看我们的攻击是否仍然可以成功。

**地址空间随机化**： Ubuntu和其他几个基于Linux的系统使用地址空间随机化来随机化堆和栈的起始地址。这使得猜测确切的地址变得困难。猜测地址是缓冲区溢出攻击的关键步骤之一。在本实验中，我们使用以下命令禁用此功能：
```shell
$ sudo sysctl -w kernel.randomize_va_space=0
```

**StackGuard保护方案**：  GCC编译器实现了一种称为StackGuard的安全机制，以防止缓冲区溢出。在这种保护的情况下，缓冲区溢出攻击将不起作用。我们可以在编译期间使用`-fno-stack-protector`选项禁用此保护。例如，要在禁用StackGuard的情况下编译程序`example.c`，我们可以执行以下操作：
```shell
$ gcc -fno-stack-protector example.c
```

**不可执行的堆栈**： Ubuntu曾经允许可执行堆栈，但是现在已经发生了变化：程序（和共享库）的二进制映像必须声明它们是否需要可执行堆栈，即它们需要在程序标头中标记一个字段。内核或动态链接器使用此标记来决定是使此正在运行的程序的堆栈是可执行的还是不可执行的。标记是由最新版本的gcc自动完成的，默认情况下，堆栈设置为不可执行。要更改此设置，请在编译程序时使用以下选项：

`对于可执行堆栈：`
```shell
$ gcc -z execstack -o test test.c
```
`对于不可执行堆栈`
```shell
$ gcc -z noexecstack -o test test.c
```

**配置 `/bin/sh` 仅适用于Ubuntu 16.04 VM）**:  在Ubuntu 12.04和Ubuntu 16.04 VM中，`/bin/sh` 符号链接均指向`/bin/dash` shell。但是，这两个VM中的`dash`程序有重要区别。Ubuntu 16.04中的`dash` shell 有一个对策，可防止自身在`Set-UID`进程中执行。基本上，如果`dash`检测到它是在`Set-UID`进程中执行的，它将立即将有效用户ID更改为该进程的真实用户ID，从而实质上删除了特权。Ubuntu 12.04中的破折号程序没有此行为。



